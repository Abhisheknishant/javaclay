
package es.bsc.dataclay.util.prefetchingspec.visitors;

import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Set;

import com.ibm.wala.cast.tree.CAstNode;
import com.ibm.wala.shrikeCT.InvalidClassFileException;
import com.ibm.wala.ssa.IR;
import com.ibm.wala.ssa.SSAInstruction;

import es.bsc.dataclay.util.prefetchingspec.analysisscopes.AnalysisScope;
import es.bsc.dataclay.util.prefetchingspec.analysisscopes.BranchAnalysisScope;
import es.bsc.dataclay.util.prefetchingspec.analysisscopes.LoopAnalysisScope;
import es.bsc.dataclay.util.prefetchingspec.analysisscopes.MultiBranchAnalysisScope;
import es.bsc.dataclay.util.prefetchingspec.wala.PrefetchingSourceLoaderImpl.PrefetchingConcreteJavaMethod;

/**
 * Creates method scopes starting from the CAst generated by WALA. Implemented using the visitor pattern.
 * 
 *
 */
public class CAst2ScopesTranslator {
	
	/** The method for which the scope are creatd. **/
	private PrefetchingConcreteJavaMethod method;
	
	/** The set of instructions per each line of source code. **/
	private HashMap<Integer, Set<SSAInstruction>> instrsPerSrcLine;
	
	/**
	 * @param methodIR
	 * 			Method IR
	 */
	public CAst2ScopesTranslator(final IR methodIR) {
		this.method = (PrefetchingConcreteJavaMethod) methodIR.getMethod();
		initializeInstrsPerSrcLineMap(methodIR);
	}

	/**
	 * @param methodIR
	 * 			Method IR
	 */
	private void initializeInstrsPerSrcLineMap(final IR methodIR) {
		this.instrsPerSrcLine = new HashMap<Integer, Set<SSAInstruction>>();
		if (methodIR == null) {
			return;
		}

		try {
			for (SSAInstruction instr : methodIR.getInstructions()) {
				// For some reason, IR might contain "null" in its instructions array!
				if (instr == null) {
					continue;
				}
				
				if (instrsPerSrcLine.get(methodIR.getMethod().getSourcePosition(instr.iindex).getFirstLine()) == null) {
					instrsPerSrcLine.put(methodIR.getMethod().getSourcePosition(instr.iindex).getFirstLine(), 
							new LinkedHashSet<SSAInstruction>());
				}
				instrsPerSrcLine.get(methodIR.getMethod().getSourcePosition(instr.iindex).getFirstLine()).add(instr);
			}
		} catch (InvalidClassFileException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Method that starts the translation process.
	 */
	public final void translate() {
		visitNode(method.getEntity().getAST(), method.getAnalysisScope());
	}

	/**
	 * Visits a node of the method's CAst.
	 * 
	 * @param node
	 * 			Node to visit
	 * @param scope
	 * 			Corresponding parent scope
	 */
	private void visitNode(final CAstNode node, final AnalysisScope scope) {
		switch (node.getKind()) {
		case CAstNode.IF_STMT:
			visitIfStmtNode(node, scope);
			break;
		case CAstNode.LOOP:
			visitLoopNode(node, scope);
			break;
		case CAstNode.SWITCH:
			visitSwitchNode(node, scope);
			break;
		case CAstNode.BLOCK_STMT:
			visitBlockNode(node, scope);
			break;
		case CAstNode.GOTO:
		case CAstNode.RETURN:
			visitBranchingStatementNode(node, scope);
			// Break is left out INTENTIONALLY. RETURN and GOTO nodes should be visited by the default visitor too.
		default:
			visitNodeDefault(node, scope);
			break;
		}
	}


	/**
	 * IF_STMT has the following structure as children:
	 * - First child: is always the evaluation node of the if condition. Node is visited normally.
	 * - Second child: can be a LOCAL_SCOPE or a node representing the instruction in the case of a single-instruction
	 * 	 if statement. Either way, a BranchAnalysisScope is created and the node is visited normally.
	 * - Third child (optional): can be:
	 * 			. LOCAL_SCOPE: representing a regular if / else block. A BranchAnalysisScope is created and the 
	 * 			  node visited normally.
	 * 			. Node representing the instruction in the case of a single-instruction else statement.
	 * 			. IF_STMT: representing an if / else-if block. In this case, a BranchAnalysisScope is NOT created.
	 * 			  The node is skipped by visiting its children directly (where an appropriate scope will be created).
	 * 			. EMPTY: does not represent anything and should be completely ignored.
	 * 		
	 * @param node
	 * 			Node to visit
	 * @param scope
	 * 			Corresponding parent scope
	 */
	private void visitIfStmtNode(final CAstNode node, final AnalysisScope scope) {
		final MultiBranchAnalysisScope multiBranchAnalysisScope = new MultiBranchAnalysisScope(method.getEntity()
				.getSourceMap().getPosition(node).getFirstLine(), -1, scope);
		scope.addChild(multiBranchAnalysisScope);
		visitIfStmtChildren(node, multiBranchAnalysisScope);
	}
	
	/**
	 * Visits children of an IF statement node.
	 * 
	 * @param node
	 * 			Node to visit
	 * @param scope
	 * 			Corresponding parent scope
	 */
	private void visitIfStmtChildren(final CAstNode node, final AnalysisScope scope) {
		// First child of an IF_STMT is always the evaluation of the if condition, visit it normally
		// Add its instructions to the PARENT scope since they will always be executed
		visitNode(node.getChild(0), scope.getParent());
		
		// An IF_STMT can have a maximum of 2 other children, the "if" and "else" scopes 
		for (int i = 1; i < node.getChildCount(); i++) {
			final CAstNode childNode = node.getChild(i);
			// An IF_STMT directly under an IF_STMT means it is an "if / else if" construct
			if (childNode.getKind() == CAstNode.IF_STMT) {
				// Skip visiting IF_STMT node again by visiting its children directly
				visitIfStmtChildren(childNode, scope);
			} else if (childNode.getKind() != CAstNode.EMPTY) {
				// Otherwise, the child can be either a LOCAL_SCOPE or the instruction directly under the if
				int startPosition = -1;
				if (method.getEntity().getSourceMap().getPosition(childNode) != null) {
					startPosition = method.getEntity().getSourceMap().getPosition(childNode).getFirstLine();
				}
				final BranchAnalysisScope branchAnalysisScope = new BranchAnalysisScope(startPosition, -1,
						(MultiBranchAnalysisScope) scope);
				scope.addChild(branchAnalysisScope);
				visitNode(childNode, branchAnalysisScope);
			}
		}
	}

	/**
	 * LOOP has a very simple structure. It starts with a LOOP statement. Its first child is a node evaluating the
	 * loop condition. Its second child is a BLOCK containing the loop body.
	 * 
	 * NOTE: This applies to "for" and "while" loops but NOT to "do-while" loops which have a completely different
	 * structure.
	 * 
	 * @param node
	 * 			Node to visit
	 * @param scope
	 * 			Corresponding parent scope
	 */
	private void visitLoopNode(final CAstNode node, final AnalysisScope scope) {
		final LoopAnalysisScope loopAnalysisScope = new LoopAnalysisScope(method.getEntity().getSourceMap().getPosition(node)
				.getFirstLine(), -1, scope);
		scope.addChild(loopAnalysisScope);
		
		// Visit the children of the LOOP node normally
		visitAllChildren(node, loopAnalysisScope);
	}

	/**
	 * SWITCH has the following structure as children:
	 * - First child is always the node representing the evaluation of the switch variable.
	 * - Second child is always a BLOCK node which contains the switch cases. Each case is represented as two
	 * 	 consecutive nodes:
	 * 		. The first is a LABEL_STMT node with the case value.
	 * 		. This is immediately followed by a BLOCK node containing the actual case body.
	 * 
	 * @param node
	 * 			Node to visit
	 * @param scope
	 * 			Corresponding parent scope
	 */
	private void visitSwitchNode(final CAstNode node, final AnalysisScope scope) {
		final MultiBranchAnalysisScope multiBranchAnalysisScope = new MultiBranchAnalysisScope(method.getEntity()
				.getSourceMap().getPosition(node).getFirstLine(), -1, scope);
		scope.addChild(multiBranchAnalysisScope);

		// The SWITCH node has two children:
		// - a VAR node representing the variable being evaluated
		// - a BLOCK node containing the LABEL_STMT nodes, each representing one case
		final CAstNode switchLabelsBlock = node.getChild(1);
		
		/** Current State Variables **/
		// This scope holds a reference to the last BranchAnalysisScope created
		BranchAnalysisScope lastBranchAnalysisScope = null;
		// This boolean is used to avoid creating two consecutive BranchAnalysisScopes when there are two 
		// consecutive "LABEL_STMT" children
		boolean createNewBranchAnalysisScope = true;
		
		for (int i = 0; i < switchLabelsBlock.getChildCount(); i++) {
			final CAstNode childNode = switchLabelsBlock.getChild(i);
			// If the child is a LABEL_STMT, create a new BranchScope and mark is as the latest
			if (childNode.getKind() == CAstNode.LABEL_STMT && createNewBranchAnalysisScope) {
				final BranchAnalysisScope branchAnalysisScope = new BranchAnalysisScope(method.getEntity()
						.getSourceMap().getPosition(childNode).getFirstLine(), -1, multiBranchAnalysisScope); 
				multiBranchAnalysisScope.addChild(branchAnalysisScope);
				
				// Update current state variables
				lastBranchAnalysisScope = branchAnalysisScope;
				createNewBranchAnalysisScope = false;
			// If the child is a BLOCK node, this is the block representing the code inside the last LABEL_STMT
			// node analyzed.
			} else if (childNode.getKind() == CAstNode.BLOCK_STMT) {
				visitNode(childNode, lastBranchAnalysisScope);
				createNewBranchAnalysisScope = true;
			}
		}
	}
	
	/**
	 * DO-WHILE has a weird structure. They start with a normal BLOCK_STMT node whose children are:
	 * 	- First child is a LABEL_STMT node with a VALUE child with the value "_do_label".
	 *  - Second child is a BLOCK_STMT node containing the actual do-while body.
	 *  - Third child is an IFGOTO node that tests the while condition.
	 *  - Fourth child is another LABEL_STMT node that marks the end of the do-while loop.
	 *  
	 * @param node
	 * 			Node to visit
	 * @param scope
	 * 			Corresponding parent scope
	 */
	private void visitBlockNode(final CAstNode node, final AnalysisScope scope) {
		// Check if this block node represents a do-while statement
		if (node.getChildCount() > 0
			&& node.getChild(0).getKind() == CAstNode.LABEL_STMT
			&& ((String) node.getChild(0).getChild(0).getValue()).equals("_do_label")) {
				final LoopAnalysisScope loopAnalysisScope = new LoopAnalysisScope(method.getEntity()
						.getSourceMap().getPosition(node.getChild(1).getChild(0)).getFirstLine(), -1, scope);
				scope.addChild(loopAnalysisScope);
				visitAllChildren(node, loopAnalysisScope);
		} else {
			visitAllChildren(node, scope);
		}
	}
	
	/**
	 * Branching statements are "continue", "break" or "return".They are only important when they are inside a
	 * BranchAnalysisScope that is inside a LoopAnalysisScope. where they might affect the execution of the loop.
	 * 
	 * @param node
	 * 			Node to visit
	 * @param scope
	 * 			Corresponding parent scope
	 */
	private void visitBranchingStatementNode(final CAstNode node, final AnalysisScope scope) {
		// If we are not inside a branch scope, ignore this node
		if (!(scope instanceof BranchAnalysisScope)) {
			return;
		}
		
		// If we are inside a loop scope, set its "hasBranchingStatements" boolean to true
		final LoopAnalysisScope parentLoopScope = scope.isInsideLoopScope();
		if (parentLoopScope != null) {
			parentLoopScope.setHasBranchingStatements(true);
		}
	}
	
	/**
	 * Visit all children of a CAst node.
	 * 
	 * @param node
	 * 			Node to visit
	 * @param scope
	 * 			Corresponding parent scope
	 */
	private void visitAllChildren(final CAstNode node, final AnalysisScope scope) {
		for (int i = 0; i < node.getChildCount(); i++) {
			visitNode(node.getChild(i), scope);
		}
	}
	
	/**
	 * The default action for this visitor is to add the instructions corresponding to this node to the scope.
	 * 
	 * @param node
	 * 			Node to visit
	 * @param scope
	 * 			Corresponding parent scope 
	 */
	private void visitNodeDefault(final CAstNode node, final AnalysisScope scope) {
		// Basically add all of the instructions corresponding to the same line as the node in the source file.
		// Since AnalysisScope.instructions is actually a Set, duplicates will not be added.
		if (method.getEntity().getSourceMap().getPosition(node) != null) {
			final int srcLine = method.getEntity().getSourceMap().getPosition(node).getFirstLine();
			if (instrsPerSrcLine.get(srcLine) != null) {
				// Add instructions to scope
				for (SSAInstruction instr : instrsPerSrcLine.get(srcLine)) {
					if (scope.getInstructions().contains(instr)) {
						continue;
					}
					scope.getInstructions().add(instr);
					method.putInstrScope(instr, scope);
				}
			}
		}
		
		// Visit children of the current node
		visitAllChildren(node, scope);
	}
}
